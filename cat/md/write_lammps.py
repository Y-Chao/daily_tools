#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import annotations

__autor__ = "Chao YANG"
__version__ = 2.0

"""
This script is used to generate a series of LAMMPS input files for the exploartion of the potential energy surface.
Description:
    1. Looking for the system configuration files
        - Default: input.data (used for training)
        - System_dir: useer provide the directory of the system configuration files (Currently, only support input.data)
        - Additional: Default + System_dir
    2. Generate the LAMMPS input files
        - SA: Simulated Annealing (for the exploration of the phase space)
        - cMD: Constrained Molecular Dynamics (for the exploration of the reaction process)
        - ...
    3. Setting a series of parameters


To do:
    1. Add tau_t and tau_p parameters for the thermostat and barostat
    2. Add long content auto-change lines.
"""

import argparse
import logging
import os
import random
from pathlib import Path
from typing import Optional, Union

from ase.atoms import Atoms
from ase.data import atomic_masses_common, atomic_numbers
from ase.io import lammpsdata, read

# from fileio import read_n2p2_data

Bohr2Ang = 0.5291772109030  # CODATA 2018
Ang2Bohr = 1 / Bohr2Ang
Eh2eV = 27.211386245988  # CODATA 2018
eV2Eh = 1 / Eh2eV


def sepline(ch="-", sep="-", screen=False, length=80):
    r"""Seperate the output by '-'."""
    ch = "  " + ch + "  "
    if screen:
        print(ch.center(length, sep))
    else:
        logging.info(ch.center(length, sep))
    return ch.center(length, sep)


def write_lammps_input(
    path: str,
    ensemble: str,
    conf_file: Union[str, Atoms],
    mlp_type: str,
    model_number: int,
    trj_freq: int,
    dump_freq: int,
    nsteps: int,
    dt: float,
    temp_s: float,
    temp_e: float,
    pres_s: float,
    pres_e: float,
    seed: list,
    restart_lmp: Optional[int],
    fixed: bool = False,
    plumed: bool = False,
    no_pbc: bool = False,
    **kwargs,
) -> None:
    """
    Write the LAMMPS input files.
    Parameters
    ----------
    path : str
        The output directory.
    ensemble : str
        The ensemble type.
    conf_file : str
        The system configuration file.
    mlp_type : str
        The type of the potential energy surface.
    model_number : int
        The number of the MLIP.
    elements : list
        The list of the elements.
    trj_freq : int
        The frequency of the trajectory output.
    dump_freq : int
        The frequency of the dump output.
    nsteps : int
        The total number of steps.
    dt : float
        The time step.
    temp_s : float
        The start temperature.
    temp_e : float
        The end temperature.
    pres_s : float
        The start pressure.
        The end pressure.
    seed : list
        The random seed.
    restart_lmp : bool
        Whether to use the restart file.
    plumed : bool
        Whether to use the PLUMED package.
    no_pbc : bool
        Whether to use the non-periodic boundary condition.
    Returns
    -------
    None
    """

    # Initialize some configuration
    # 1. The potential energy surface
    #       - dp: DeepPot
    #       - n2p2: Neural Network Potential Package
    #       - ...
    # 2. The ensemble type
    #       - nvt: NVT ensemble, check the temperature term
    #       - npt: NPT ensemble, check the temperature and pressure term
    #       - ...
    # 3. The configuration file should contains the information of the system
    #       - Constraint or relax atom type
    #       - Different part of the system, bulk, surface, solvation
    #       - ...

    if mlp_type == "dp":
        potential = "deepmd"
        units = "metal"
        atom_style = "atomic"
    elif mlp_type == "mace":
        potential = "mace"
        units = "metal"
        atom_style = "atomic"
    else:
        raise ValueError(f"Unknown potential energy surface: {mlp_type}")

    if ensemble == "nvt" or "npt":
        if temp_s != temp_e or temp_e is None:
            temp_e = temp_s
        if temp_s is None:
            raise ValueError("The temperature should be provided.")
        if ensemble == "npt":
            if pres_s != pres_e or pres_e is None:
                pres_e = pres_s
            if pres_s is None:
                raise ValueError("The pressure should be provided.")
    else:
        raise ValueError(f"Unknown ensemble: {ensemble}")

    if isinstance(conf_file, str):
        conf_file = Path(path) / "conf.lmp"
        atoms = read(conf_file)

    elif isinstance(conf_file, Atoms):
        atoms = conf_file
        write_lammps_structure_ase(path, atoms)

    """
        Write the LAMMPS input files.
    """
    ret = f"{'#This scipt is generated by write_lammps.py':<80}\n"
    ret += "\n"
    ret += f"{sepline('Variables', sep='#', length=80)}\n"
    ret += f"{'variable':<15}{'NSTEPS':<15}{'equal':<10}{nsteps:<10}\n"
    ret += f"{'variable':<15}{'THERMO_FREQ':<15}{'equal':<10}{trj_freq:<10}\n"
    ret += f"{'variable':<15}{'DUMP_FREQ':<15}{'equal':<10}{dt:<10}\n"
    ret += f"{'variable':<15}{'TEMP':<15}{'equal':<10}{temp_s:<10}\n"
    ret += f"{'variable':<15}{'PRES':<15}{'equal':<10}{pres_s:<10}\n"
    ret += f"{'variable':<15}{'SEED1':<15}{'equal':<10}{seed[0]:<10}\n"
    ret += f"{'variable':<15}{'SEED2':<15}{'equal':<10}{seed[1]:<10}\n"
    ret += "\n"

    ret += f"{sepline('Global', sep='#', length=80)}\n"
    ret += f"{'units':<15}{units:<10}\n"
    if no_pbc:
        ret += f"{'boundary':<15}{'f':<2}{'f':<2}{'f':<2}\n"
    else:
        ret += f"{'boundary':<15}{'p':<2}{'p':<2}{'p':<2}\n"

    if restart_lmp:
        ret += f"{'read_restart':<15}restart.lmp\n"
    ret += f"{'restart':<15}{'50000':<10}{'lmp.restart':<10}\n"
    ret += f"{'atom_style':<15}{atom_style:<10}\n"
    ret += f"{'neigh_modify':<15}{'delay':<10} 10 {'every':<10} 1\n"
    ret += f"{'read_data':<15}{'conf.lmp':<10}\n"

    ret += "\n"
    ret += f"{sepline('Atomic', sep='#', length=80)}\n"
    elements = list(set(atoms.get_chemical_symbols()))
    elements = sorted(elements, key=lambda x: atomic_numbers[x])
    for i in range(len(elements)):
        ret += f"{'mass':<15}{i+1:<10}{atomic_masses_common[atomic_numbers[elements[i]]-1]:.4f}\n"

    ret += "\n"
    ret += f"{sepline('Force Field', sep='#', length=80)}\n"
    if mlp_type == "dp":
        if model_number == 1:
            model_path = "../model.pth"
        else:
            model_path = " ".join(
                [f"../model_{i}.pth" for i in range(1, model_number + 1)]
            )
            model_path += " out_freq ${THERMO_FREQ} outfile model_devi.out"
        ret += f"{'pair_style':<15}{'deepmd':<10}{model_path}\n"
        ret += f"{'pair_coeff':<15}{'*':<10}{'*':<10}\n"

    ret += "\n"
    ret += f"{sepline('Group', sep='#', length=80)}\n"
    if fixed and kwargs.get("constraints", None) is not None:
        ret += f"{'group':<15}{'atoms1':<10} id {' '.join(map(str, kwargs['constraints']))}\n"
        if kwargs.get("unconstrained", None) is None:
            kwargs["unconstrained"] = [
                i + 1 for i in range(len(atoms)) if i + 1 not in kwargs["constraints"]
            ]
        ret += f"{'group':<15}{'atoms2':<10} id {' '.join(map(str, kwargs['unconstrained']))}\n"
        write_fixed = True
    else:
        write_fixed = False
    ret += ""

    ret += "\n"
    ret += f"{sepline('Minimization', sep='#', length=80)}\n"
    ret += f"{'#minimize':<15}1.0e-6 1.0e-6 1000 10000\n"

    ret += "\n"
    ret += f"{sepline('Timestep', sep='#', length=80)}\n"
    ret += f"{'timestep':<15}{dt:<10}    #ps\n"
    ret += f"{'thermo':<15}{'${THERMO_FREQ}':<10}\n"
    ret += f"{'thermo_style':<15}{'custom':<19} step temp pe ke etotal press vol lx ly lz xy xz yz\n"
    ret += f"{'thermo_modify':<15}{'flush':<10} yes\n"

    ret += "\n"
    ret += f"{sepline('Dump', sep='#', length=80)}\n"
    ret += f"{'dump':<15}{'1':<10} all custom ${{DUMP_FREQ}} all.lammpstrj id type x y z fx fy fz\n"

    ret += "\n"
    ret += f"{sepline('Ensemble', sep='#', length=80)}\n"
    ret += f"{'reset_timestep':<15}0\n"
    if write_fixed:
        ret += f"{'velocity':<15}atoms1 set 0.0 0.0 0.0\n"
        ret += f"{'velocity':<15}atoms2 create ${{TEMP}} $SEED1 dist gaussian\n"
        ret += f"{'fix':<15}{'1':<10} atoms1 setforce 0.0 0.0 0.0\n"
        if ensemble == "nvt":
            # ret += f"{'#fix':<15}{'2':<10} atoms2 nvt temp ${{TEMP}} ${{TEMP}} ${{TAU_T}}\n"
            ret += (
                f"{'fix':<15}{'2':<10} atoms2 nve temp ${{TEMP}} ${{TEMP}} ${{TAU_T}}\n"
            )
            ret += f"{'fix':<15}{'3':<10} atoms2 temp/csvr ${{TEMP}} ${{TEMP}} ${{TAU_T}} ${{SEED2}}\n"
        elif ensemble == "npt":
            pass
        else:
            pass
    else:
        ret += f"{'velocity':<15}all create ${{TEMP}} $SEED1 dist gaussian\n"
        if ensemble == "nvt":
            # ret += f"{'fix':<15}{'1':<10} all nvt temp ${{TEMP}} ${{TEMP}} ${{TAU_T}}\n"
            ret += f"{'fix':<15}{'1':<10} all nve temp ${{TEMP}} ${{TEMP}} ${{TAU_T}}\n"
            ret += f"{'fix':<15}{'2':<10} all temp/csvr ${{TEMP}} ${{TEMP}} ${{TAU_T}} ${{SEED2}}\n"
        elif ensemble == "npt":
            pass
        else:
            pass

    if plumed:
        ret += f"{'fix':<15}{'plumed':<10} all plumed plumedfile plumed.dat outfile output.plumed\n"

    ret += f"{'run':<15}${{NSTEPS}}\n"

    if write_fixed:
        ret += f"{'unfix':<15}{'1':<10}\n"
        ret += f"{'unfix':<15}{'2':<10}\n"
        ret += f"{'unfix':<15}{'3':<10}\n"
    else:
        ret += f"{'unfix':<15}{'1':<10}\n"
        ret += f"{'unfix':<15}{'2':<10}\n"

    if plumed:
        ret += f"{'unfix':<15}{'plumed':<10}\n"

    with open(os.path.join(path, "input.lammps"), "w") as f:
        f.write(ret)


def write_lammps_structure(
    path, lattice, element, position, q, element_types, masses, atom_style
):
    """
    Write the LAMMPS input files.
    """
    pass


def write_lammps_structure_ase(path, atoms):
    """
    Write the LAMMPS input files.
    """
    path = Path(path) / "conf.lmp"
    order = list(set(atoms.get_chemical_symbols()))
    order.sort(key=lambda x: atomic_numbers[x])
    lammpsdata.write_lammps_data(path, atoms, specorder=order)


def main():
    parser = argparse.ArgumentParser(
        "Generate the LAMMPS input files for the exploration of the potential energy surface."
    )
    parser.add_argument(
        "-i", "--input_trj", type=str, help="The system configuration file."
    )
    parser.add_argument("-o", "--output", type=str, help="The output directory.")
    parser.add_argument("-t", "--temp", type=str, help="The temperature.")
    parser.add_argument(
        "-e", "--ensemble", type=str, default="nvt", help="The ensemble type."
    )
    parser.add_argument(
        "--fixed", type=bool, default=False, help="Whether to fix some atoms."
    )
    parser.add_argument(
        "--plumed", type=bool, default=False, help="Whether to use plumed."
    )

    args = parser.parse_args()
    if not os.path.exists(args.input_trj):
        raise FileNotFoundError(f"The input file {args.input_trj} does not exist.")
    # atoms = read_n2p2_data(args.input_trj, index='-1')
    atoms = read(args.input_trj, index="-1")

    if not os.path.exists(args.output):
        os.makedirs(args.output)

    write_lammps_structure_ase(
        path=args.output,
        atoms=atoms,
    )

    if args.fixed:
        if len(atoms.constraints) > 0:
            cind = atoms.constraints[0].index
            extra_info = {
                "constraints": [i + 1 for i in cind],
                "unconstrained": [i + 1 for i in range(len(atoms)) if i not in cind],
            }
        else:
            extra_info = {}

    write_lammps_input(
        path=args.output,
        ensemble=args.ensemble,
        conf_file=atoms,
        mlp_type="dp",
        model_number=4,
        trj_freq=50,
        dump_freq=50,
        nsteps=20000,
        dt=0.0005,
        temp_s=args.temp,
        temp_e=args.temp,
        pres_s=1.0,
        pres_e=1.0,
        seed=[random.randrange(1, 1000001) for _ in range(2)],
        restart_lmp=False,
        plumed=args.plumed,
        fixed=args.fixed,
        **extra_info,
    )


if __name__ == "__main__":
    main()
